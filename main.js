/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HeatmapCalendarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/js/Log.ts
var NAME = "HeatmapCalendar";
var level = 1 /* error */;
var Logger = class {
  constructor(level2, mod) {
    this.modName = "";
    if (level2) {
      this.modLevel = level2;
    }
    if (mod) {
      this.modName = ` ${mod}:`;
    }
  }
  setLevel(level2) {
    this.modLevel = level2;
  }
  get level() {
    return this.modLevel || level;
  }
  log(fn, ...args) {
    fn(NAME, ...args);
  }
  info(...args) {
    if (this.level >= 2 /* info */) {
      this.log(console.info, "[INFO]" + this.modName, ...args);
    }
  }
  debug(...args) {
    if (this.level >= 3 /* debug */) {
      this.log(console.debug, "[DEBUG]" + this.modName, ...args);
    }
  }
  error(...args) {
    if (this.level >= 1 /* error */) {
      this.log(console.error, "[ERROR]" + this.modName, ...args);
    }
  }
  module(moduleName) {
    return new Logger(this.modLevel, moduleName);
  }
};
var Log_default = new Logger();

// src/js/SettingsStore.ts
var DEFAULT_CONFIG = {
  year: new Date().getUTCFullYear(),
  colors: {
    default: ["#c6e48b", "#7bc96f", "#49af5d", "#2e8840", "#196127"]
  },
  entries: [{ date: "1900-01-01", color: "#7bc96f", intensity: 5, content: "" }],
  showCurrentDayBorder: true,
  defaultEntryIntensity: 4,
  intensityScaleStart: 1,
  intensityScaleEnd: 5
};
var DEFAULT_SETTINGS = {
  startDayOfWeek: 0
};
var SettingsStore = class {
  constructor() {
    this.config = DEFAULT_CONFIG;
    this.settings = DEFAULT_SETTINGS;
  }
  setConfig(initial) {
    this.config = initial;
  }
  getConfig(prop) {
    return this.config[prop];
  }
  setSettings(initial) {
    this.settings = initial;
  }
  getSetting(prop) {
    return this.settings[prop];
  }
  set defaultPalette(name) {
    this._defaultPalette = name;
  }
  get defaultPalette() {
    return this._defaultPalette;
  }
  get dayOfWeekStart() {
    return this.settings.startDayOfWeek;
  }
  get dayOfWeekEnd() {
    return (this.dayOfWeekStart + 6) % 7;
  }
};
var SettingsStore_default = new SettingsStore();

// src/js/DateUtil.ts
var ONE_DAY_MILI = 1e3 * 60 * 60 * 24;
var ONE_YEAR_MILI = ONE_DAY_MILI * 365;
var DOW = {
  SUN: 0,
  MON: 1,
  TUE: 2,
  WED: 3,
  THU: 4,
  FRI: 5,
  SAT: 6
};
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var padLeft = (input, length) => {
  let str = input.toString();
  while (str.length < length)
    str = "0" + str;
  return str;
};
var getDateString = (date) => {
  return [date.getUTCFullYear(), padLeft(date.getUTCMonth() + 1, 2), padLeft(date.getUTCDate(), 2)].join("-");
};
var datesMatch = (d1, d2) => {
  if (typeof d1 !== "string")
    d1 = getDateString(d1);
  if (typeof d2 !== "string")
    d2 = getDateString(d2);
  return d1 === d2;
};
var incrementDate = (date, count = 1) => {
  return new Date(date.getTime() + ONE_DAY_MILI * count);
};
var decrementDate = (date, count = 1) => {
  return new Date(date.getTime() - ONE_DAY_MILI * count);
};
var timeFloorDate = (date) => {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
};
var getNow = () => {
  return timeFloorDate(new Date(Date.now()));
};
var isToday = (date) => {
  return datesMatch(date, getNow());
};
var getEndOfWeekDate = (midweekDate, endOfWeek = DOW.SAT) => {
  let endDate = timeFloorDate(midweekDate);
  while (endDate.getUTCDay() !== endOfWeek)
    endDate = incrementDate(endDate);
  return endDate;
};
var getStartOfWeekDate = (midweekDate, startOfWeek = DOW.SUN) => {
  let startDate = timeFloorDate(midweekDate);
  while (startDate.getUTCDay() !== startOfWeek)
    startDate = decrementDate(startDate);
  return startDate;
};

// src/js/Layout.ts
var DOW_LABELS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var Layout = class {
  filterEntries() {
    throw new Error("Not Implemented");
  }
  generateBoxes() {
    throw new Error("Not Implemented");
  }
  getMonthLabels() {
    throw new Error("Not Implemented");
  }
  getDayOfWeekLabels() {
    let dowStart = SettingsStore_default.dayOfWeekStart;
    return [...DOW_LABELS.slice(dowStart), ...DOW_LABELS.slice(0, dowStart)];
  }
  get startDayOfWeek() {
    return SettingsStore_default.dayOfWeekStart;
  }
};

// src/js/Box.ts
var BoxImpl = class {
  constructor(date) {
    this.classes = [];
    this.date = date;
  }
  static fromDate(date, isLeading = false) {
    let box = new BoxImpl(getDateString(date));
    if (isLeading)
      box.classes.push("notInView" /* LEADING */);
    return box;
  }
  static fromEntry(entry) {
    let boxi = new BoxImpl(entry.date);
    boxi.entry = entry;
    return boxi;
  }
  get backgroundColor() {
    if (this.entry) {
      if (this.entry.color)
        return this.entry.color;
      return "#000";
    }
    if (this.classes.includes("notInView" /* LEADING */)) {
      return "transparent";
    }
    return "";
  }
  get content() {
    return this.entry ? this.entry.content : null;
  }
  get classNames() {
    this.classes.push(this.entry ? "hasData" /* HAS_DATA */ : "isEmpty" /* IS_EMPTY */);
    if (SettingsStore_default.getConfig("showCurrentDayBorder") && isToday(this.date)) {
      this.classes.push("today" /* TODAY */);
    }
    return this.classes.join(" ");
  }
};

// src/js/RollingLayout.ts
var log = Log_default.module("RollingLayout");
var getRollingStartDate = () => {
  let now = getNow();
  let minusAYear = new Date(now.getTime() - ONE_YEAR_MILI);
  return getStartOfWeekDate(minusAYear, SettingsStore_default.dayOfWeekStart);
};
var getRollingEndDate = () => {
  let now = getNow();
  return getEndOfWeekDate(now, SettingsStore_default.dayOfWeekEnd);
};
var RollingLayout = class extends Layout {
  constructor(entries) {
    super();
    this.allEntries = entries;
  }
  filterEntries() {
    var _a;
    let now = getNow();
    let startDate = getRollingStartDate();
    let endDate = getRollingEndDate();
    log.info("Start date:", startDate, "End date:", endDate);
    return (_a = [...this.allEntries].filter((e) => {
      let eDate = new Date(e.date);
      return eDate >= startDate && eDate <= endDate;
    })) != null ? _a : this.allEntries;
  }
  generateBoxes() {
    let now = getNow();
    let startDate = getRollingStartDate();
    let endDate = getRollingEndDate();
    let boxes = [];
    endDate = incrementDate(endDate);
    let check = 0;
    while (startDate < endDate) {
      boxes.push(BoxImpl.fromDate(startDate));
      startDate = incrementDate(startDate);
      check++;
      if (check > 390) {
        throw new Error("generateBoxes check thrown. Too many iterations");
      }
    }
    return boxes;
  }
  getMonthLabels() {
    let monthOffset = getNow().getUTCMonth() + 1;
    let orderedMonths = [];
    for (let i = 0; i < 12; i++) {
      orderedMonths.push(MONTHS[(monthOffset + i) % 12]);
    }
    return orderedMonths;
  }
};

// src/js/YearLayout.ts
var log2 = Log_default.module("YearLayout");
var getHowManyDaysIntoYear = (date) => {
  return (Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()) - Date.UTC(date.getUTCFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
};
var getHowManyDaysIntoYearLocal = (date) => {
  return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
};
var YearLayout = class extends Layout {
  constructor(year, entries) {
    super();
    this.allEntries = entries;
    this.year = year;
  }
  getMonthLabels() {
    return MONTHS;
  }
  filterEntries() {
    var _a;
    return (_a = this.allEntries.filter((e) => new Date(e.date + "T00:00").getUTCFullYear() === this.year)) != null ? _a : this.allEntries;
  }
  generateBoxes() {
    const { year } = this;
    const firstDayOfYear = new Date(Date.UTC(year, 0, 1));
    let leadingDays = getStartOfWeekDate(firstDayOfYear, SettingsStore_default.dayOfWeekStart);
    log2.debug("Year start date:", getDateString(leadingDays), "Year end date:", getDateString(firstDayOfYear));
    const boxes = [];
    while (leadingDays < firstDayOfYear) {
      boxes.push(BoxImpl.fromDate(leadingDays, true));
      leadingDays = incrementDate(leadingDays);
    }
    const lastDayOfYear = new Date(Date.UTC(year, 11, 31));
    const numberOfDaysInYear = getHowManyDaysIntoYear(lastDayOfYear);
    const todaysDayNumberLocal = getHowManyDaysIntoYearLocal(getNow());
    for (let day = 0; day <= numberOfDaysInYear; day++) {
      let boxDate = incrementDate(firstDayOfYear, day);
      boxes.push(BoxImpl.fromDate(boxDate));
    }
    return boxes;
  }
};

// src/js/Entry.ts
var log3 = Log_default.module("Entry");
var Entry = class {
  constructor(e) {
    this.entry = e;
  }
  get date() {
    return this.entry.date;
  }
  get intensity() {
    let defaultI = SettingsStore_default.getConfig("defaultEntryIntensity");
    if (this.entry.intensity === void 0) {
      log3.debug(`Entry ${this.date} intensity is Undefined`);
      return defaultI || 0;
    }
    if (this.entry.intensity === 0) {
      log3.debug(`Entry ${this.date} intensity is ZER0`);
      return 0;
    }
    return this.entry.intensity;
  }
  get color() {
    return this.entry.color || SettingsStore_default.defaultPalette;
  }
};

// src/js/Intensor.ts
var log4 = Log_default.module("Intensor");
var DEFAULT_COLOR = "#e2e2e2";
var makeLinearFunc = (x1, y1, x2, y2) => {
  let slope = (y2 - y1) / (x2 - x1);
  let offset = (x2 * y1 - x1 * y2) / (x2 - x1);
  return (x) => x * slope + offset;
};
var clamp = (input, min, max) => {
  return input < min ? min : input > max ? max : input;
};
var Intensor = class {
  constructor(settings, colors, entries) {
    this.colors = colors;
    this.colorNames = Object.keys(colors);
    if (!this.colorNames.length) {
      throw new Error(`Misconfigured Intensor; no ColorOptions passed`);
    }
    let [minimumIntensity, maximumIntensity] = this.getDataRange(entries, settings);
    this.colorFunctions = /* @__PURE__ */ new Map();
    Object.keys(colors).forEach((key) => {
      let colorValues = colors[key];
      let colorSpace = [0, colorValues.length];
      let inputSpace = [minimumIntensity, maximumIntensity];
      log4.info(`Creating function for "${key}"; mapping inputs(${inputSpace}) to colorspace(${colorSpace})`);
      this.colorFunctions.set(key, makeLinearFunc(inputSpace[0], colorSpace[0], inputSpace[1], colorSpace[1]));
    }, {});
  }
  getDataRange(entries, settings) {
    let intensities = entries.map((e) => new Entry(e)).filter((e) => e.intensity).map((e) => e.intensity);
    let maxInData = Math.max(...intensities) + 1;
    let minInData = Math.min(...intensities);
    let result = [minInData, maxInData];
    if (settings.intensityScaleStart || settings.intensityScaleStart === 0) {
      result[0] = settings.intensityScaleStart;
    }
    if (settings.intensityScaleEnd || settings.intensityScaleEnd === 0) {
      result[1] = settings.intensityScaleEnd + 1;
    }
    return result;
  }
  getDefaultPalette() {
    return this.colorNames[0] || "default";
  }
  mapEntry(entryProps) {
    let entry = new Entry(entryProps);
    let paletteName = entry.color || this.getDefaultPalette();
    let paletteValues = this.colors[paletteName];
    if (this.colorFunctions.has(paletteName)) {
      let colorFn = this.colorFunctions.get(paletteName);
      if (!colorFn) {
        log4.error(`No color function for ${paletteName}`);
        return DEFAULT_COLOR;
      }
      let funcResult = colorFn(entry.intensity);
      let colorIndex = clamp(Math.ceil(funcResult), 0, paletteValues.length - 1);
      let colorValue = paletteValues[colorIndex];
      log4.debug(`Mapped value ${entry.intensity} to ${colorValue} (fn: ${funcResult})`);
      return colorValue;
    } else {
      log4.error(`No color function found for "${paletteName}" with intensity [${entry.intensity}]`);
      return DEFAULT_COLOR;
    }
  }
};

// src/js/HeatmapCalendar.ts
var HeatmapCalendar = class {
  constructor(settings, config) {
    this.settings = settings;
    this.config = config;
  }
  render(el) {
    SettingsStore_default.setConfig(this.config);
    SettingsStore_default.setSettings(this.settings);
    const { year, rolling, colors, entries } = this.config;
    const layout = rolling ? new RollingLayout(entries) : new YearLayout(year, entries);
    const calEntries = layout.filterEntries();
    let intensor = new Intensor(this.config, colors, calEntries);
    const boxes = layout.generateBoxes();
    calEntries.forEach((e) => {
      let match = boxes.find((b) => b.date === e.date);
      if (match) {
        match.entry = e;
      }
      e.color = intensor.mapEntry(e);
    });
    const heatmapCalendarGraphDiv = createDiv({
      cls: "heatmap-calendar-graph",
      parent: el
    });
    createDiv({
      cls: "heatmap-calendar-year",
      text: String(year).slice(2),
      parent: heatmapCalendarGraphDiv
    });
    const heatmapCalendarMonthsUl = createEl("ul", {
      cls: "heatmap-calendar-months",
      parent: heatmapCalendarGraphDiv
    });
    layout.getMonthLabels().forEach((ml) => {
      createEl("li", { text: ml, parent: heatmapCalendarMonthsUl });
    });
    const heatmapCalendarDaysUl = createEl("ul", {
      cls: "heatmap-calendar-days",
      parent: heatmapCalendarGraphDiv
    });
    layout.getDayOfWeekLabels().forEach((dow) => {
      createEl("li", { text: dow, parent: heatmapCalendarDaysUl });
    });
    const heatmapCalendarBoxesUl = createEl("ul", {
      cls: "heatmap-calendar-boxes",
      parent: heatmapCalendarGraphDiv
    });
    boxes.forEach((e) => {
      createEl("li", {
        text: e.content,
        attr: __spreadValues({}, e.backgroundColor && { style: `background-color: ${e.backgroundColor};` }),
        cls: e.classNames,
        parent: heatmapCalendarBoxesUl
      });
    });
  }
};

// src/js/SettingsTab.ts
var import_obsidian = require("obsidian");
var DOW_OPTIONS = {
  "0": "Sunday",
  "1": "Monday"
};
var HeatmapCalendarSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("First Day of Week").setDesc("Day of week to start on").addDropdown((dropdown) => {
      dropdown.addOptions(DOW_OPTIONS).setValue(this.plugin.settings.startDayOfWeek.toString()).onChange((value) => __async(this, null, function* () {
        console.log(value);
        this.plugin.settings.startDayOfWeek = parseInt(value);
        yield this.plugin.saveSettings();
      }));
    });
  }
};

// main.ts
var HeatmapCalendarPlugin = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      Log_default.setLevel(3 /* debug */);
      yield this.loadSettings();
      console.log(this.settings);
      this.addSettingTab(new HeatmapCalendarSettingsTab(this.app, this));
      window.renderHeatmapCalendar = (el, config) => {
        let mergedConfig = Object.assign({}, DEFAULT_CONFIG, config);
        let heatmap = new HeatmapCalendar(this.settings, mergedConfig);
        heatmap.render(el);
      };
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, { "startDayOfWeek": 0 }, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
